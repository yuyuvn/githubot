// Generated by CoffeeScript 1.9.3
(function() {
  var Github, func, github, http, method, querystring, ref, version;

  http = require("scoped-http-client");

  querystring = require("querystring");

  version = require("../package.json")["version"];

  Github = (function() {
    function Github(options1) {
      this.options = options1;
    }

    Github.prototype.withOptions = function(specialOptions) {
      var k, newOpts, ref, v;
      newOpts = {};
      ref = this.options;
      for (k in ref) {
        v = ref[k];
        newOpts[k] = v;
      }
      for (k in specialOptions) {
        v = specialOptions[k];
        newOpts[k] = v;
      }
      return new Github(newOpts);
    };

    Github.prototype.qualified_repo = function(repo) {
      var user;
      if (repo == null) {
        if ((repo = this._opt("defaultRepo")) == null) {
          return null;
        }
      }
      repo = repo.toLowerCase();
      if (repo.indexOf("/") !== -1) {
        return repo;
      }
      if ((user = this._opt("defaultUser")) == null) {
        return repo;
      }
      return user + "/" + repo;
    };

    Github.prototype.request = function(verb, url, data) {
      var args, oauth_token, req, url_api_base;
      url_api_base = this._opt("apiRoot");
      if (url.slice(0, 4) !== "http") {
        if (url[0] !== "/") {
          url = "/" + url;
        }
        url = "" + url_api_base + url;
      }
      req = http.create(url).header("Accept", "application/vnd.github." + (this._opt("apiVersion")) + "+json");
      req = req.header("User-Agent", "GitHubot/" + version);
      oauth_token = this._opt("token");
      if (oauth_token != null) {
        req = req.header("Authorization", "token " + oauth_token);
      }
      args = [];
      if (data != null) {
        args.push(JSON.stringify(data));
      }
      if (verb === "DELETE" && (data == null)) {
        args.push("");
      }
      return new Promise(function(resolve, reject) {
        return req[verb.toLowerCase()].apply(req, args)((function(_this) {
          return function(err, res, body) {
            var e, ref, responseData;
            if (err != null) {
              reject({
                statusCode: res != null ? res.statusCode : void 0,
                body: res != null ? res.body : void 0,
                error: err
              });
            }
            try {
              if (body) {
                responseData = JSON.parse(body);
              }
            } catch (_error) {
              e = _error;
              reject({
                statusCode: res.statusCode,
                body: body,
                error: "Could not parse response: " + body
              });
            }
            if ((200 <= (ref = res.statusCode) && ref < 300)) {
              return resolve(responseData);
            } else {
              return reject({
                statusCode: res.statusCode,
                body: body,
                error: responseData != null ? responseData.error : void 0
              });
            }
          };
        })(this));
      });
    };

    Github.prototype.get = function(url, data) {
      if (data != null) {
        url += "?" + querystring.stringify(data);
      }
      return this.request("GET", url);
    };

    Github.prototype.post = function(url, data, cb) {
      return this.request("POST", url, data);
    };

    Github.prototype["delete"] = function(url, cb) {
      return this.request("DELETE", url);
    };

    Github.prototype.put = function(url, data, cb) {
      return this.request("PUT", url, data);
    };

    Github.prototype.patch = function(url, data, cb) {
      return this.request("PATCH", url, data);
    };

    Github.prototype.handleErrors = function(callback) {
      return this.options.errorHandler = callback;
    };

    Github.prototype._opt = function(optName) {
      var ref;
      if (this.options == null) {
        this.options = {};
      }
      return (ref = this.options[optName]) != null ? ref : this._optFromEnv(optName);
    };

    Github.prototype._optFromEnv = function(optName) {
      var ref, ref1, ref2;
      switch (optName) {
        case "token":
          return process.env.HUBOT_GITHUB_TOKEN;
        case "concurrentRequests":
          return (ref = process.env.HUBOT_CONCURRENT_REQUESTS) != null ? ref : 20;
        case "defaultRepo":
          return process.env.HUBOT_GITHUB_REPO;
        case "defaultUser":
          return process.env.HUBOT_GITHUB_USER;
        case "apiRoot":
          return (ref1 = process.env.HUBOT_GITHUB_API) != null ? ref1 : "https://api.github.com";
        case "apiVersion":
          return (ref2 = process.env.HUBOT_GITHUB_API_VERSION) != null ? ref2 : "v3";
        default:
          return null;
      }
    };

    return Github;

  })();

  module.exports = github = function(options) {
    if (options == null) {
      options = {};
    }
    return new Github(options);
  };

  ref = Github.prototype;
  for (method in ref) {
    func = ref[method];
    github[method] = func;
  }

}).call(this);
